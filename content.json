{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"Categories","date":"2025-11-28T12:56:54.861Z","updated":"2025-11-28T12:56:54.861Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2025-11-28T12:56:54.860Z","updated":"2025-11-28T12:56:54.860Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2025-11-28T12:56:54.862Z","updated":"2025-11-28T12:56:54.862Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OLAP数据库","slug":"八股文整理/数据库/OLAP数据库","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-01T16:57:39.396Z","comments":true,"path":"2025/12/02/八股文整理/数据库/OLAP数据库/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/OLAP%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"OLAP 分析型数据库1. 定义OLAP（Online Analytical Processing，联机分析处理） 是一种以分析和决策支持为主要目的的数据库系统，用于： 数据汇总、统计、分析 发现业务规律、趋势预测 支持复杂查询和报表 特点： 数据量大，通常是历史数据 查询复杂，包含聚合、分组、排序 更新频率低，主要是读取和批量加载 2. OLAP 与 OLTP 对比 特性 OLTP（事务型） OLAP（分析型） 主要用途 事务处理，记录操作 数据分析、决策支持 数据量 小到中等 很大，通常是历史数据 查询类型 简单，点查或小范围 复杂，聚合、统计、趋势分析 更新频率 高频，实时更新 低，批量更新或定期加载 表结构 高度规范化（NF） 宽表&#x2F;星型&#x2F;雪花模式 典型场景 下单、支付、库存更新 BI报表、数据挖掘、决策分析 3. OLAP 数据库特点 低更新高查询 一般是只读或少量批量写入 多维分析（Multidimensional Analysis） 支持按不同维度切分数据（如时间、地区、产品） 聚合和统计优化 使用预计算聚合表或位图索引加速查询 常见技术 列存储数据库：ClickHouse、Vertica 数据仓库：Snowflake、Hive、BigQuery 总结 OLAP分析型数据库是为决策支持和复杂分析而优化的数据库，特点是查询多、更新少、数据量大，与事务型数据库 OLTP 完全不同。","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"数据库","slug":"八股文整理/数据库","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"mysql三个引擎的区别","slug":"八股文整理/数据库/mysql两个引擎的区别","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-01T16:51:13.041Z","comments":true,"path":"2025/12/02/八股文整理/数据库/mysql两个引擎的区别/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%A4%E4%B8%AA%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"MySQL 三个常用存储引擎的区别：InnoDB vs MyISAM vs Memory🔍 InnoDB vs MyISAM vs Memory 核心区别 1. 事务支持（Transaction） InnoDB：支持事务、ACID、回滚、提交、崩溃恢复 MyISAM：不支持事务 Memory：不支持事务 2. 锁机制 InnoDB：行级锁（Row Lock），高并发性能强 MyISAM：表级锁（Table Lock），读优先的有偏锁 Memory：表级锁（Table Lock），读写均衡的无偏锁 主要由其使用场景决定（见6） 3. 数据存储位置 InnoDB：数据 + 索引存磁盘 MyISAM：数据（.MYD）+ 索引（.MYI）存磁盘 Memory：数据全部存内存（重启数据即丢失） 4. 数据安全性 InnoDB：强，支持崩溃恢复 MyISAM：弱，宕机可能损坏 Memory：无，重启数据全清空 5. 性能特点 InnoDB：写多、事务场景最佳 MyISAM：读多、轻量、查询快 Memory：极快（内存级速度），适合临时数据或缓存 6. 典型使用场景✔ InnoDB 金融、订单、支付、用户系统等需要事务的场景 ✔ MyISAM 日志分析、查询频繁但较少更新的表 ✔ Memory（内存引擎） 临时表 热点数据缓存 快速计算、存放中间结果 排序、统计时的高速中间表 📌 三者对比表 特性 InnoDB MyISAM Memory 数据存储 磁盘 磁盘 内存 是否持久化 ✔ 是 ✔ 是 ✘ 否 事务 ✔ 支持 ✘ 不支持 ✘ 不支持 锁类型 行锁 表锁 表锁 崩溃恢复 ✔ 支持 ✘ 不支持 ✘ 不支持 读性能 高 高 极高 写性能 中 高 极高 场景 事务、并发 查询多 临时、高速 💡 Memory Engine 特别注意 数据存内存，重启全部丢失 索引默认是 HASH 索引（极快） 适合需要“读写极快但不需要持久化”的表","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"数据库","slug":"八股文整理/数据库","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"dns与httpdns","slug":"八股文整理/计算机网络/dns与httpdns","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-05T08:23:13.776Z","comments":true,"path":"2025/12/02/八股文整理/计算机网络/dns与httpdns/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dns%E4%B8%8Ehttpdns/","excerpt":"","text":"📘 DNS 相关对话（Q&#x2F;A 格式整理版）Q1. 我记得还有一个设计上 HTTPDNS，也给我讲讲？A：你可以把 HTTPDNS 理解为”DNS over HTTP&#x2F;HTTPS 的自建版本”，与 DoH（DNSover HTTPS）有相似点，但定位不同。 它主要解决的问题是：传统 DNS 经常被运营商劫持、污染、缓存错误，特别是在移动网络环境。 因此一些大厂（阿里、腾讯、字节）自建 HTTPDNS，让客户端通过 HTTP&#x2F;HTTPS访问专门的 DNS 服务，以避免运营商干扰。 Q2. 我的理解是：HTTPDNS 是一个单独分类，请帮我对比传统 DNS 和 HTTPDNS？A：下面是传统 DNS 与 HTTPDNS 的对比表： 对比项 传统 DNS HTTPDNS 传输协议 UDP&#x2F;53（也可 TCP&#x2F;53） HTTP 或 HTTPS 易受运营商劫持 是 否 数据格式 DNS 二进制格式 JSON &#x2F; 自定义格式 走代理 通常不走 容易走（HTTP&#x2F;HTTPS） CDN 就近策略 不一定准确（取决于本地 可以根据真实客户端 IP DNS） 精确调度 移动网络环境 易被劫持 非常稳定 延迟 很低 一般略高（HTTP 请求） 适合场景 PC、固定网络 移动 APP、大厂业务、特定网络环境 Q3. 但是实际上 HTTPDNS 服务器的解析也要依赖传统 DNS？A：是的，这是关键点。 HTTPDNS 只是”客户端访问 DNS 的方式改变了”，但它本质上仍要： 向权威 DNS 获取域名记录\\ 或自己作为递归去向 Root → TLD → Authoritative 逐级解析 HTTPDNS 不会改变 DNS 的基础结构，只是绕过运营商的 Local DNS。 Q4. HTTPDNS 是否需要在 DNS 中填写 DNS 服务器域名？还是直接使用 IP 构造 HTTP 访问？A：HTTPDNS 客户端通常必须 直接使用固定 IP 访问 HTTPDNS 服务。不能用域名，否则就又要解析 DNS，形成循环。 因此请求通常是： http://203.107.1.1/resolve?host=example.com 或通过 HTTPS： https://203.107.1.1/resolve IP 是写死的。 Q5. 但是一般来说，HTTP 层的 IP 直连处于安全考虑应该关闭的吧？A：这里需要区分两类服务： 1）普通 Web 服务大多数网站确实会关闭 IP 直连： 防止绕过 CDN\\ 防止源站暴露\\ 防止攻击者扫描\\ 防止证书 mismatch 2）HTTPDNS 服务这是基础设施服务 → 必须支持 IP 直连。否则客户端无法启动 DNS 解析链路。 所以： 业务网站：IP 直连关闭\\ HTTPDNS：必须开放 IP 两者不矛盾。 Q6. 类似于”浏览器里填的是 IP，但是在协议里还是域名”？A：对 HTTPS 来说确实如此。 流程是： 浏览器访问 IP\\ 但 TLS 握手会发 SNI（Server Name Indication），里面包含域名\\ 服务器根据域名选择证书和站点 若不发送 SNI 或证书不匹配，服务器通常拒绝访问。 Q7. 但是实际上构造攻击时也可以使用这种方式，那关闭 IP 直接访问的意义是什么？A：关闭 IP直连并不是为了”绝对阻止攻击”，而是为了”降低攻击面、增加成本”。 意义包括： 隐藏源站 IP\\ 防止绕过 CDN &#x2F; WAF\\ 过滤扫描器（大多数扫描器不会构造复杂 SNI&#x2F;Host）\\ 避免证书泄露源站信息\\ 阻止简单脚本攻击\\ 缩小暴露面 这是典型的防御原则： 不是阻止攻击，而是让攻击变得困难且成本高。 Q8. 但其实用反向 DNS 获取真实业务域名，再伪造 Host 也可以攻击？A：这是一个常见误区，实际情况如下： 1）绝大多数业务 IP 没有 PTR 记录尤其是云服务、CDN、源站。 2）有 PTR 的 IP 也通常不是业务域名多是： xxx.provider.net xxx.cloud.internal 完全无意义。 3）即便知道域名，也无法绕过： CDN\\ WAF\\ Token &#x2F; Session &#x2F; Cookie 鉴权\\ API gateway 限制 4）源站通常不暴露因为： 托管在私网\\ 仅 CDN IP 白名单可访问\\ 或通过 SLB 内部网络访问 所以反向 DNS 不会让攻击更容易。 Q9. 也就是说并非”阻止”，而是”加大难度”？A：完全正确。 这正是现代安全的核心思想： 安全不是绝对阻止，而是尽可能提高攻击难度，使其成本超出价值。 IP 直连关闭、域名 Host 验证、CDN 前置……都是这一策略的表现。","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"计算机网络","slug":"八股文整理/计算机网络","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"数据库的三种索引","slug":"八股文整理/数据库/数据库的三种索引","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-01T16:58:26.106Z","comments":true,"path":"2025/12/02/八股文整理/数据库/数据库的三种索引/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B4%A2%E5%BC%95/","excerpt":"","text":"数据库索引类型总结数据库常见的索引类型有 Hash索引、Tree索引（B-Tree&#x2F;B+Tree） 和 BitMap索引。下面是详细对比。 1. Hash 索引原理：通过哈希函数将键值映射到哈希表槽位，直接定位数据。 特点： 查询速度快（精确匹配 O(1)） 不支持范围查询（&gt;、BETWEEN 等） 可能存在哈希冲突，需要链表等方法解决 适用场景： 高速精确匹配查询 不需要排序或范围查找 缺点： 不支持范围查询 哈希冲突可能影响性能 内存占用较大 2. Tree 索引（B-Tree&#x2F;B+Tree）原理：采用平衡树（B-Tree&#x2F;B+Tree），节点按键值有序，叶子节点存储数据指针。 特点： 支持范围查询（&lt;, &gt;, BETWEEN） 支持精确查询 查找复杂度 O(log n) 适用场景： 需要排序、范围查询或模糊查询 高并发场景 缺点： 插入&#x2F;删除可能涉及节点分裂&#x2F;合并，开销较大 占用空间比Hash略多 3. BitMap 索引（位图索引）原理：用位向量表示每个值在表中对应行的存在与否，通过位运算快速查询。 特点： 查询效率高（尤其低基数字段） 占用空间小（可压缩） 支持复杂条件组合的快速查询 适用场景： 只读或少量更新的场景 字段基数低（如性别、状态） OLAP分析型数据库 缺点： 高基数字段不适合 更新成本高 索引对比总结 特性 Hash索引 Tree索引 (B+Tree) BitMap索引 精确查询 ✅ 很快 ✅ 快 ✅ 快 范围查询 ❌ ✅ ✅（低基数） 排序 ❌ ✅ ✅（低基数） 占用空间 中等&#x2F;大 中等 低（基数低） 更新&#x2F;插入 快 中等 慢 最适场景 精确查找 范围查询、排序 OLAP分析、低基数字段","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"数据库","slug":"八股文整理/数据库","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"cgroup","slug":"八股文整理/操作系统/系统工具/cgroup","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-01T17:21:25.411Z","comments":true,"path":"2025/12/02/八股文整理/操作系统/系统工具/cgroup/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/cgroup/","excerpt":"","text":"Linux cgroup 笔记总结1. 名词定义 cgroup（Control Group）Linux 内核提供的资源管理机制，用于对一组进程进行资源限制、监控和控制。 controller（子系统 &#x2F; 控制器）每种资源类型的控制模块，例如： cpu：CPU 时间分配 memory：内存使用限制 blkio：磁盘 I&#x2F;O 限制 hierarchy（层级 &#x2F; 树）cgroup 组织成树状结构，每个节点是一个 cgroup，挂载在文件系统下（如 /sys/fs/cgroup）。 同一个 cgroup指 共享同一套资源限制的一组进程。内核会统一统计这些进程的资源使用，并施加相同的限制。 CPU 相对优先级（cpu.shares）表示 cgroup 在 CPU 竞争时的权重比例，默认 1024。 只影响 CPU 分配比例，不限制最大使用量。 CPU 绝对限制（cpu.cfs_quota_us &#x2F; cpu.cfs_period_us）表示每个调度周期内该 cgroup 最多能使用的 CPU 时间。 超过 quota 的线程不会被调度，硬性限制。 2. cgroup 原理 层级 + controller cgroup 通过层级树组织，每个节点可挂载一个或多个 controller。 controller 提供对特定资源的管理。 进程与 cgroup cgroup 管理的是 task_struct（进程&#x2F;线程）。 进程加入 cgroup 后，受到该 cgroup 所有 controller 的限制。 资源限制类型 绝对限制（Quota &#x2F; Limit）：硬性上限，如 cpu.cfs_quota_us 或 memory.limit_in_bytes 相对优先级（Shares &#x2F; 权重）：在资源竞争时按比例分配，如 cpu.shares、blkio.weight 调度逻辑（以 CPU 为例） 先满足 绝对限制（quota） 剩余资源按 相对优先级 分配 同一 cgroup 内所有线程共享 quota 和 shares 配置 父子 cgroup 限制与覆盖 子 cgroup 可以 覆盖父节点的限制，例如 CPU shares 可以改成不同值 内核不会自动“取最小值”或“取最大值”，子节点生效的是自己设置的限制 某些资源（如 memory）可能仍受父节点总量约束，但调度器不会对 quota 做 min&#x2F;max 处理 子 cgroup quota 大于父节点 quota 子 cgroup 可以设置比父节点更大的 quota 实际可用 CPU 仍受父节点总 quota 限制 内核调度逻辑：子 cgroup 想用的 CPU &#x3D; min(父节点剩余 CPU, 子节点 quota) 3. 常见问题及解释Q1: 一个 cgroup 能同时设置绝对限制和相对权重吗？A: 可以。 quota &#x3D; CPU 的硬性上限 shares &#x3D; 剩余 CPU 的分配比例 调度器会先限制 quota，再按 shares 分配剩余 CPU Q2: 如果同一系统中，一个 cgroup 用绝对限制，一个用相对权重，会怎样？A: 绝对限制 cgroup：最多使用 quota 指定的 CPU 时间 相对权重 cgroup：分配剩余 CPU 按权重比例 绝对限制不会因为有相对 cgroup 而减少 Q3: quota 很高，shares 很低会怎样？A: quota 很高 &#x3D; 硬上限很大 shares 很低 &#x3D; 在 CPU 竞争时优先级低 实际 CPU 占用可能远低于 quota，因为 shares 决定了分配顺序 Q4: 同一个 cgroup 内，能让部分线程使用绝对限制，部分线程使用相对优先级吗？A: 不可以。 CPU controller 的限制是 cgroup 级别的 要实现不同策略，需要将线程划分到不同 cgroup 4. 常用文件接口（以 CPU 为例） cpu.shares：相对权重 cpu.cfs_quota_us：绝对 CPU 限制（微秒） cpu.cfs_period_us：调度周期（微秒） tasks：写入 PID，将进程加入 cgroup 5. 小结 cgroup &#x3D; 共享同一套资源限制的进程组 controller &#x3D; 管理特定资源的模块 CPU 调度可同时配置： quota（绝对限制）：硬性上限 shares（相对优先级）：剩余 CPU 分配比例 调度逻辑： 先满足 quota 剩余资源按 shares 分配 父子 cgroup 限制： 子 cgroup 可以覆盖父节点的限制 内核不会自动取最小或最大值 父节点 quota 会约束子节点实际可用 CPU 子 cgroup quota 大于父节点也无法突破父节点总量 不同策略的线程必须放入 不同 cgroup","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"操作系统","slug":"八股文整理/操作系统","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"系统工具","slug":"八股文整理/操作系统/系统工具","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"tcp挥手与断开","slug":"八股文整理/计算机网络/传输层协议/TCP/挥手过程","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-05T09:37:46.749Z","comments":true,"path":"2025/12/02/八股文整理/计算机网络/传输层协议/TCP/挥手过程/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Simultaneous FIN（TCP 同时关闭）系统整理1. 定义Simultaneous FIN 又叫 TCP Simultaneous Close，指的是： TCP 连接的双方几乎同时发起关闭连接请求 双方都发送了 FIN 报文，而不是传统的主动关闭与被动关闭模式 最终仍然能够可靠地关闭 TCP 连接 简单理解：双方几乎同时挂电话，最终电话顺利断开。 2. 与普通 TCP 四次挥手的区别 特性 普通 TCP 四次挥手 Simultaneous FIN 发起者 一方主动关闭，一方被动关闭 双方几乎同时主动关闭 FIN 报文 单方发送 双方几乎同时发送 ACK 回复 被动方回复 ACK 双方互相回复 ACK 状态顺序 ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED 双方同时经历 FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED 场景 客户端主动关闭，服务器被动关闭 对等通信（P2P）关闭连接 3. 关闭流程（详细三步）3.1 初始状态假设两台主机 A 和 B 已建立连接： 12A: ESTABLISHEDB: ESTABLISHED A → B：发送 FIN B → A：发送 FIN 两台主机状态变为 FIN_WAIT_1 3.2 收到对方 FIN A 收到 B 的 FIN → 回复 ACK（确认号 &#x3D; B 的序列号 +1） B 收到 A 的 FIN → 回复 ACK（确认号 &#x3D; A 的序列号 +1） 双方状态变为 FIN_WAIT_2 注意：如果 FIN 与 ACK 交叉到达，TCP 可以在同一报文中同时发送 FIN+ACK。 3.3 TIME_WAIT 与关闭 双方进入 TIME_WAIT 状态，以确保延迟报文不会影响新连接 TIME_WAIT 超时后，状态变为 CLOSED 4. 流程时序图1234567891011时间 --&gt; A B | FIN ------------------------&gt; | | &lt;------------------------ FIN | | ACK ------------------------&gt; | | &lt;------------------------ ACK | FIN_WAIT_2 FIN_WAIT_2 | | TIME_WAIT TIME_WAIT | | CLOSED CLOSED 说明： 双向箭头表示 TCP 报文流向 双方最终进入 CLOSED，连接完全关闭 若 FIN 与 ACK 交叉，可合并为 FIN+ACK 报文 5. 特点与要点 双向主动关闭双方都主动发起 FIN，TCP 自动处理报文确认 可靠性TCP 的序列号、确认号、重传机制仍然生效，保证连接正常关闭 全双工释放双方都可以在发送 FIN 之前继续发送剩余数据 少见场景对等通信（P2P）中可能出现，普通客户端-服务器模式下较少 状态机双方都经历 FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED 6. 注意事项 端口释放TIME_WAIT 状态保证延迟报文不会影响新连接，防止端口冲突 防火墙与 NAT防火墙或 NAT 可能会阻止 FIN 报文，需要确保双方网络环境允许 TCP 标准支持RFC 793 支持 Simultaneous Close，但在实际网络中较少使用 7. 总结 Simultaneous FIN 是 TCP 的 特殊关闭机制 双方几乎同时发送 FIN，最终仍能可靠关闭连接 本质上仍遵循 TCP 四次挥手，只是双方都主动关闭 典型应用：对等网络通信（P2P）关闭连接","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"计算机网络","slug":"八股文整理/计算机网络","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层协议","slug":"八股文整理/计算机网络/传输层协议","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"name":"TCP","slug":"八股文整理/计算机网络/传输层协议/TCP","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/"}],"tags":[]},{"title":"tcp握手与链接","slug":"八股文整理/计算机网络/传输层协议/TCP/握手过程","date":"2025-12-01T16:41:00.000Z","updated":"2025-12-05T08:57:22.719Z","comments":true,"path":"2025/12/02/八股文整理/计算机网络/传输层协议/TCP/握手过程/","permalink":"http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/","excerpt":"","text":"寻常三次握手略，大部分的书上都会说 Simultaneous SYN（TCP 同时打开）系统整理1. 定义Simultaneous SYN 又叫 TCP Simultaneous Open，指的是： TCP 连接的双方几乎同时发起建立连接请求 双方都发送了 SYN 报文，而不是传统的客户端-服务器模式 最终仍然能够成功建立一个可靠的双向 TCP 连接 简单理解：双方都想主动打电话，结果电话“撞”在一起，最终双方都能通话。 2. 与普通 TCP 建立连接的区别 特性 普通 TCP 三次握手 Simultaneous SYN 发起者 明确客户端 → 服务器 双方都主动发起 SYN 报文 单方发送 双方几乎同时发送 ACK 回复 服务器回复客户端的 SYN 双方互相回复对方的 SYN 状态顺序 CLOSED → SYN_SENT → SYN_RECEIVED → ESTABLISHED 双方都经历 CLOSED → SYN_SENT → SYN_RECEIVED → ESTABLISHED 场景 常规客户端-服务器通信 对等通信（P2P） 3. 建立流程（详细三步）3.1 初始状态假设两台主机 A 和 B： 12A: CLOSEDB: CLOSED A → B：发送 SYN（序列号 x） B → A：发送 SYN（序列号 y） 两台主机状态变为 SYN_SENT 3.2 收到对方 SYN A 收到 B 的 SYN → 回复 SYN+ACK（确认号 y+1，序列号 x） B 收到 A 的 SYN → 回复 SYN+ACK（确认号 x+1，序列号 y） 状态变为 SYN_RECEIVED 3.3 最终确认 A 收到 B 的 SYN+ACK → 发送 ACK（确认号 y+1） B 收到 A 的 SYN+ACK → 发送 ACK（确认号 x+1） 双方状态最终都变为 ESTABLISHED 4. 流程时序图123456789时间 --&gt; A B | SYN(x) ---------------------&gt; | | &lt;-------------------- SYN(y) | | SYN+ACK(x,y+1) -------------&gt; | | &lt;------------ SYN+ACK(y,x+1) | | ACK(y+1) ------------------&gt; | | &lt;------------------ ACK(x+1) | ESTABLISHED ESTABLISHED 说明： 横向箭头表示 TCP 报文流向 x 和 y 分别为双方的初始序列号 双方最终都进入 ESTABLISHED 状态 5. 特点与要点 全双工通道最终建立的 TCP 连接和普通 TCP 连接一样，全双工可靠通信 双方都是主动发起者没有传统客户端&#x2F;服务器角色对等网络（P2P）中可能出现 可靠性TCP 序列号、确认号、重传机制依然生效 少见场景普通客户端-服务器模式下几乎不会用到对等通信、某些分布式系统或 P2P 协议可能会遇到 状态机双方都经历 SYN_SENT → SYN_RECEIVED → ESTABLISHED与普通三次握手类似，但双方都发送了 SYN 6. 注意事项 端口监听问题Simultaneous SYN 仍然需要一方或双方的端口处于监听状态，否则会被拒绝 防火墙和 NAT某些防火墙可能阻止同时发起的 SYN 报文NAT 环境下可能会导致连接失败 TCP 标准支持RFC 793 明确支持 Simultaneous Open实际上，很多操作系统都实现了，但不常用 7. 总结 Simultaneous SYN 是 TCP 的一个 特殊建立连接机制 双方都主动发送 SYN，最终仍然建立可靠连接 本质上仍是 TCP 的三次握手，只是双方都是主动发起者 典型应用：对等网络通信（P2P）","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"计算机网络","slug":"八股文整理/计算机网络","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"传输层协议","slug":"八股文整理/计算机网络/传输层协议","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"name":"TCP","slug":"八股文整理/计算机网络/传输层协议/TCP","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/"}],"tags":[]},{"title":"锁相关知识点","slug":"八股文整理/JAVA/锁部分","date":"2025-12-01T02:15:00.000Z","updated":"2025-12-01T16:41:48.103Z","comments":true,"path":"2025/12/01/八股文整理/JAVA/锁部分/","permalink":"http://example.com/2025/12/01/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/JAVA/%E9%94%81%E9%83%A8%E5%88%86/","excerpt":"","text":"概述java的锁其实主要可以分成三种，syncro锁，reentrain锁，以及更经典传统的无锁机制。 synchronized锁synchronized 是 Java 的内置锁（Intrinsic Lock &#x2F; Monitor Lock），作用： 同一时刻只能有一个线程进入被同步的代码块或方法（互斥） 保证线程之间的 可见性（基于进入与退出 Monitor 的内存语义） 自动加锁、自动释放（异常也会释放） 使用方法1234567891011synchronized (lockObject) &#123; // 临界区&#125;public synchronized void test() &#123; // 临界区&#125;public static synchronized void testStatic() &#123; // 临界区&#125; 其中，后面两种修饰方法在锁上，等效于将本实例或者本class作为锁对象的第一种方法，因此这里会产生一个问题，如果两个不同的代码段使用第二种方法进行竞争，这两个代码段也会产生一个锁竞争，这样的坏处是，可能会造成意外的锁竞争，好处是对于 ** ‘synchronizedMap’ **这样的数据结构，能保证它的多功能多线程安全。 原理这个锁的原理是基于Monitor锁进行，每个 Java 对象都可以作为一个 Monitor，JVM 为每个对象维护一个称为 Object Monitor 的监视器结构，线程通过进入和退出 Monitor 来实现同步互斥。一个 Monitor 包含： 1）Owner（持有者） 当前占用锁的线程（如果为 null，说明锁空闲）。 2）EntryList（锁竞争队列） 等待获取锁的线程队列。 3）WaitSet（等待队列） 调用 wait() 后进入此队列，等待 notify() 或 notifyAll() 唤醒。 4）recursions（重入次数） 支持可重入锁（持有者可以多次进入，同样次数退出后才能释放） 12345678monitorenter ↓进入 Monitor（尝试成为 Owner） ↓成功 → 执行临界区代码 ↓monitorexit（释放锁） 在字节码中，sync会被编译成 123monitorenter ... 临界区 ...monitorexit 的形式。 同时， 注意事项ReentrantLock原理底层使用： AQS（AbstractQueuedSynchronizer） CAS（compare and swap） 获取或释放锁 volatile 保证可见性 CLH 双向队列管理等待线程 LockSupport.park&#x2F;unpark 挂起与唤醒线程 锁之间的比较12345678910111213141516171819202122232425262728┌───────────────────────────────────────────┐│ Java 代码层 │└───────────────────────────────────────────┘ │ │ ▼ ▼ synchronized 代码 ReentrantLock.lock() │ │ ▼ ▼┌───────────────────────────────────────────┐│ JVM 层（HotSpot 实现） │└───────────────────────────────────────────┘ Monitorenter/Monitorexit AQS(CLH队列)+CAS Monitor(WaitSet/EntryList) LockSupport.park/unpark │ │ ▼ ▼┌───────────────────────────────────────────┐│ Native (Unsafe) │└───────────────────────────────────────────┘ OS Mutex / Thread Park unsafe.park() ThreadBlock/Schedule unsafe.unpark() │ │ ▼ ▼┌───────────────────────────────────────────┐│ OS 层 (Linux / Windows) │└───────────────────────────────────────────┘ futex(mutex lock/wait/wake) futex(FUTEX_WAIT/FUTEX_WAKE) system call thread switch system call thread switch","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"JAVA","slug":"八股文整理/JAVA","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/JAVA/"}],"tags":[]},{"title":"","slug":"八股文整理/计算机网络/协议分层","date":"2025-11-30T16:34:35.919Z","updated":"2025-11-30T16:34:35.919Z","comments":true,"path":"2025/12/01/八股文整理/计算机网络/协议分层/","permalink":"http://example.com/2025/12/01/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82/","excerpt":"","text":"","categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"计算机网络","slug":"八股文整理/计算机网络","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"lc 1590. 使数组和能被 P 整除","slug":"算法题整理/lc 1590. 使数组和能被 P 整除","date":"2025-11-30T15:59:59.000Z","updated":"2025-11-30T16:32:35.623Z","comments":true,"path":"2025/11/30/算法题整理/lc 1590. 使数组和能被 P 整除/","permalink":"http://example.com/2025/11/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/lc%201590.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB%20P%20%E6%95%B4%E9%99%A4/","excerpt":"","text":"题目链接lc超链接 算法思路主要思想是：假设整个数组模 p 之后的结果是 x，那么我们需要在数组中移除一个子数组，使得这个子数组模 p 的结果也是 x。从数学角度可以证明，移除这个子数组后，原数组的模会减少 x，从而变成 0。 举个例子，假设有五个数，它们模 p 的结果是 x，只要移除其中一个模 p 结果为 x 的子数组，那么剩下的数模 p 就是 0。 暴力算法思路最直观的想法是：对于每一个起点 i，枚举以它为起点的所有子数组，直到找到一个子数组的模 p 结果为 x，或者遍历到数组末尾。 如果找到匹配的子数组，就用它来更新”最短子数组长度”这个变量。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123; //长短指针循环法 int n=nums.size(); int sum_mod=0; for(auto a:nums)&#123; sum_mod+=a; sum_mod%=p; &#125; if(sum_mod==0)&#123; return 0; &#125; int min_leng=INT_MAX; for(int i=0;i&lt;n;i++)&#123; int sum_mod_temp=0; for(int j=i;j&lt;n;j++)&#123; sum_mod_temp+=(nums[j]%p); sum_mod_temp%=p; if(sum_mod==sum_mod_temp)&#123; min_leng=min(min_leng,j-i+1); break; &#125; &#125; &#125; if(min_leng==INT_MAX || min_leng==n)&#123; return -1; &#125; return min_leng; &#125;&#125;; 结果该方法会超时，最坏时间复杂度为 O(n²)。空间复杂度为 O(1)。 优化算法（官解）另一种思路是使用前缀和配合哈希表的方法。 对于任意一个位置 i，考虑以该位置为结尾的前缀和。我们需要找到一个子数组，使得该子数组的模 p 结果等于 x。利用前缀和的性质，如果当前前缀和的模为 y，那么我们需要找到一个之前的前缀和，使得两个前缀和的模差为 x。 为了找到最短的子数组，对于任意一个位置，我们只需要找到它左边最近的一个满足条件的前缀和即可。因此，我们可以使用一个哈希表（字典），来记录每个前缀和模 p 值对应的最近位置。 我的代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123; unordered_map&lt;int,int&gt; right_mod; int sum_mod=0; int n=nums.size(); int min_len=INT_MAX; //取需要消掉的模 int total_x=0; for(auto a:nums)&#123; total_x+=a; total_x%=p; &#125; cout&lt;&lt;total_x&lt;&lt;endl; //在整个数组中消去一段，这一段的模差应该是total_x for(int i=0;i&lt;n;i++)&#123; sum_mod=(sum_mod+nums[i])%p; if(sum_mod==total_x)&#123; min_len=min(min_len,i+1); &#125; if(right_mod[(sum_mod+p-total_x)%p]!=0)&#123; min_len=min(min_len,i-right_mod[(sum_mod+p-total_x)%p]+1); cout&lt;&lt;i-right_mod[(sum_mod+p-total_x)%p]+1&lt;&lt;&quot;-&quot;&lt;&lt;endl; &#125; right_mod[sum_mod]=i+1; cout&lt;&lt;min_len&lt;&lt;endl; &#125; if(sum_mod==0)&#123; return 0; &#125; return min_len==n?-1:min_len; &#125;&#125;; 官解123456789101112131415161718192021222324252627class Solution &#123;public: int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123; int x = 0; for (auto num : nums) &#123; x = (x + num) % p; &#125; if (x == 0) &#123; return 0; &#125; unordered_map&lt;int, int&gt; index; int y = 0, res = nums.size(); for (int i = 0; i &lt; nums.size(); i++) &#123; index[y] = i; // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i y = (y + nums[i]) % p; if (index.count((y - x + p) % p) &gt; 0) &#123; res = min(res, i - index[(y - x + p) % p] + 1); &#125; &#125; return res == nums.size() ? -1 : res; &#125;&#125;;作者：力扣官方题解链接：https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/2157277/shi-shu-zu-he-neng-bei-p-zheng-chu-by-le-dob9/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 复杂度对每个数遍历一遍，时间复杂度为 O(n)。需要一个哈希表存储每个余数对应的位置，空间复杂度为 O(n)。 我的解与官方解法的对比及注意事项 index.count() 的使用：我之前没有使用过这个方法，所以用了一个”0”值来标记某个键是否真的出现过，位置记录也需要相应的偏移，这是不必要的。使用 index.count() 可以直接判断键是否存在。 sum_mod==total_x 的判断：这个判断其实是没必要的，因为这个情况实际上会映射到哈希表的”0”键，可以通过哈希表统一处理。 更新顺序的差异：官解中的 index[y] 和我的更新顺序不太一样，官解是在下一轮循环中更新的，这个顺序问题不大，但需要注意边界情况的处理。 一些笔记涉及取模运算的问题，很多时候可以利用同余性质和哈希表来优化。 当需要优化时间复杂度时，前缀和配合哈希表往往是一个可行的思路。","categories":[{"name":"算法题整理","slug":"算法题整理","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"}],"tags":[]},{"title":"第一篇日志","slug":"测试用/第一篇日志","date":"2025-11-28T12:43:57.000Z","updated":"2025-11-29T07:42:54.808Z","comments":true,"path":"2025/11/28/测试用/第一篇日志/","permalink":"http://example.com/2025/11/28/%E6%B5%8B%E8%AF%95%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E5%BF%97/","excerpt":"","text":"","categories":[{"name":"测试用","slug":"测试用","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8/"}],"tags":[]},{"title":"Hello World","slug":"测试用/hello-world","date":"2025-11-28T11:46:34.811Z","updated":"2025-11-28T11:46:34.811Z","comments":true,"path":"2025/11/28/测试用/hello-world/","permalink":"http://example.com/2025/11/28/%E6%B5%8B%E8%AF%95%E7%94%A8/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"测试用","slug":"测试用","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8/"}],"tags":[]}],"categories":[{"name":"八股文整理","slug":"八股文整理","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"},{"name":"数据库","slug":"八股文整理/数据库","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"八股文整理/计算机网络","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"八股文整理/操作系统","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"系统工具","slug":"八股文整理/操作系统/系统工具","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"},{"name":"传输层协议","slug":"八股文整理/计算机网络/传输层协议","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"},{"name":"TCP","slug":"八股文整理/计算机网络/传输层协议/TCP","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/"},{"name":"JAVA","slug":"八股文整理/JAVA","permalink":"http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/JAVA/"},{"name":"算法题整理","slug":"算法题整理","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"},{"name":"测试用","slug":"测试用","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8/"}],"tags":[]}