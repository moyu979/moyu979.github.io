<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-12-01T16:57:39.396Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OLAP数据库</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/OLAP%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/OLAP%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-01T16:57:39.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OLAP-分析型数据库"><a href="#OLAP-分析型数据库" class="headerlink" title="OLAP 分析型数据库"></a>OLAP 分析型数据库</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p><strong>OLAP（Online Analytical Processing，联机分析处理）</strong> 是一种以<strong>分析和决策支持</strong>为主要目的的数据库系统，用于：</p><ul><li>数据汇总、统计、分析  </li><li>发现业务规律、趋势预测  </li><li>支持复杂查询和报表</li></ul><p><strong>特点：</strong></p><ul><li>数据量大，通常是历史数据  </li><li>查询复杂，包含聚合、分组、排序  </li><li>更新频率低，主要是读取和批量加载</li></ul><hr><h2 id="2-OLAP-与-OLTP-对比"><a href="#2-OLAP-与-OLTP-对比" class="headerlink" title="2. OLAP 与 OLTP 对比"></a>2. OLAP 与 OLTP 对比</h2><table><thead><tr><th>特性</th><th>OLTP（事务型）</th><th>OLAP（分析型）</th></tr></thead><tbody><tr><td>主要用途</td><td>事务处理，记录操作</td><td>数据分析、决策支持</td></tr><tr><td>数据量</td><td>小到中等</td><td>很大，通常是历史数据</td></tr><tr><td>查询类型</td><td>简单，点查或小范围</td><td>复杂，聚合、统计、趋势分析</td></tr><tr><td>更新频率</td><td>高频，实时更新</td><td>低，批量更新或定期加载</td></tr><tr><td>表结构</td><td>高度规范化（NF）</td><td>宽表&#x2F;星型&#x2F;雪花模式</td></tr><tr><td>典型场景</td><td>下单、支付、库存更新</td><td>BI报表、数据挖掘、决策分析</td></tr></tbody></table><hr><h2 id="3-OLAP-数据库特点"><a href="#3-OLAP-数据库特点" class="headerlink" title="3. OLAP 数据库特点"></a>3. OLAP 数据库特点</h2><ol><li><p><strong>低更新高查询</strong>  </p><ul><li>一般是只读或少量批量写入</li></ul></li><li><p><strong>多维分析（Multidimensional Analysis）</strong>  </p><ul><li>支持按不同维度切分数据（如时间、地区、产品）</li></ul></li><li><p><strong>聚合和统计优化</strong>  </p><ul><li>使用预计算聚合表或位图索引加速查询</li></ul></li><li><p><strong>常见技术</strong>  </p><ul><li>列存储数据库：ClickHouse、Vertica  </li><li>数据仓库：Snowflake、Hive、BigQuery</li></ul></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>OLAP分析型数据库是为<strong>决策支持和复杂分析</strong>而优化的数据库，特点是<strong>查询多、更新少、数据量大</strong>，与事务型数据库 OLTP 完全不同。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OLAP-分析型数据库&quot;&gt;&lt;a href=&quot;#OLAP-分析型数据库&quot; class=&quot;headerlink&quot; title=&quot;OLAP 分析型数据库&quot;&gt;&lt;/a&gt;OLAP 分析型数据库&lt;/h1&gt;&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql三个引擎的区别</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%A4%E4%B8%AA%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%A4%E4%B8%AA%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-01T16:51:13.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-三个常用存储引擎的区别：InnoDB-vs-MyISAM-vs-Memory"><a href="#MySQL-三个常用存储引擎的区别：InnoDB-vs-MyISAM-vs-Memory" class="headerlink" title="MySQL 三个常用存储引擎的区别：InnoDB vs MyISAM vs Memory"></a>MySQL 三个常用存储引擎的区别：InnoDB vs MyISAM vs Memory</h1><h2 id="🔍-InnoDB-vs-MyISAM-vs-Memory-核心区别"><a href="#🔍-InnoDB-vs-MyISAM-vs-Memory-核心区别" class="headerlink" title="🔍 InnoDB vs MyISAM vs Memory 核心区别"></a>🔍 InnoDB vs MyISAM vs Memory 核心区别</h2><hr><h2 id="1-事务支持（Transaction）"><a href="#1-事务支持（Transaction）" class="headerlink" title="1. 事务支持（Transaction）"></a><strong>1. 事务支持（Transaction）</strong></h2><ul><li><strong>InnoDB：支持事务、ACID、回滚、提交、崩溃恢复</strong></li><li><strong>MyISAM：不支持事务</strong></li><li><strong>Memory：不支持事务</strong></li></ul><hr><h2 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2. 锁机制"></a><strong>2. 锁机制</strong></h2><ul><li><strong>InnoDB：行级锁（Row Lock），高并发性能强</strong></li><li><strong>MyISAM：表级锁（Table Lock），读优先的有偏锁</strong></li><li><strong>Memory：表级锁（Table Lock），读写均衡的无偏锁</strong></li></ul><p>主要由其使用场景决定（见6）</p><hr><h2 id="3-数据存储位置"><a href="#3-数据存储位置" class="headerlink" title="3. 数据存储位置"></a><strong>3. 数据存储位置</strong></h2><ul><li><strong>InnoDB：数据 + 索引存磁盘</strong></li><li><strong>MyISAM：数据（.MYD）+ 索引（.MYI）存磁盘</strong></li><li><strong>Memory：数据全部存内存（重启数据即丢失）</strong></li></ul><hr><h2 id="4-数据安全性"><a href="#4-数据安全性" class="headerlink" title="4. 数据安全性"></a><strong>4. 数据安全性</strong></h2><ul><li><strong>InnoDB：强，支持崩溃恢复</strong></li><li><strong>MyISAM：弱，宕机可能损坏</strong></li><li><strong>Memory：无，重启数据全清空</strong></li></ul><hr><h2 id="5-性能特点"><a href="#5-性能特点" class="headerlink" title="5. 性能特点"></a><strong>5. 性能特点</strong></h2><ul><li><strong>InnoDB：写多、事务场景最佳</strong></li><li><strong>MyISAM：读多、轻量、查询快</strong></li><li><strong>Memory：极快（内存级速度），适合临时数据或缓存</strong></li></ul><hr><h2 id="6-典型使用场景"><a href="#6-典型使用场景" class="headerlink" title="6. 典型使用场景"></a><strong>6. 典型使用场景</strong></h2><h3 id="✔-InnoDB"><a href="#✔-InnoDB" class="headerlink" title="✔ InnoDB"></a>✔ InnoDB</h3><ul><li>金融、订单、支付、用户系统等需要事务的场景</li></ul><h3 id="✔-MyISAM"><a href="#✔-MyISAM" class="headerlink" title="✔ MyISAM"></a>✔ MyISAM</h3><ul><li>日志分析、查询频繁但较少更新的表</li></ul><h3 id="✔-Memory（内存引擎）"><a href="#✔-Memory（内存引擎）" class="headerlink" title="✔ Memory（内存引擎）"></a>✔ Memory（内存引擎）</h3><ul><li>临时表  </li><li>热点数据缓存  </li><li>快速计算、存放中间结果  </li><li>排序、统计时的高速中间表</li></ul><hr><h2 id="📌-三者对比表"><a href="#📌-三者对比表" class="headerlink" title="📌 三者对比表"></a>📌 三者对比表</h2><table><thead><tr><th>特性</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>数据存储</td><td>磁盘</td><td>磁盘</td><td>内存</td></tr><tr><td>是否持久化</td><td>✔ 是</td><td>✔ 是</td><td>✘ 否</td></tr><tr><td>事务</td><td>✔ 支持</td><td>✘ 不支持</td><td>✘ 不支持</td></tr><tr><td>锁类型</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>崩溃恢复</td><td>✔ 支持</td><td>✘ 不支持</td><td>✘ 不支持</td></tr><tr><td>读性能</td><td>高</td><td>高</td><td>极高</td></tr><tr><td>写性能</td><td>中</td><td>高</td><td>极高</td></tr><tr><td>场景</td><td>事务、并发</td><td>查询多</td><td>临时、高速</td></tr></tbody></table><hr><h2 id="💡-Memory-Engine-特别注意"><a href="#💡-Memory-Engine-特别注意" class="headerlink" title="💡 Memory Engine 特别注意"></a>💡 Memory Engine 特别注意</h2><ul><li><strong>数据存内存，重启全部丢失</strong></li><li>索引默认是 <strong>HASH 索引</strong>（极快）</li><li>适合需要“读写极快但不需要持久化”的表</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-三个常用存储引擎的区别：InnoDB-vs-MyISAM-vs-Memory&quot;&gt;&lt;a href=&quot;#MySQL-三个常用存储引擎的区别：InnoDB-vs-MyISAM-vs-Memory&quot; class=&quot;headerlink&quot; title=&quot;MySQ</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>dns与httpdns</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dns%E4%B8%8Ehttpdns/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/dns%E4%B8%8Ehttpdns/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-05T08:23:13.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📘-DNS-相关对话（Q-A-格式整理版）"><a href="#📘-DNS-相关对话（Q-A-格式整理版）" class="headerlink" title="📘 DNS 相关对话（Q&#x2F;A 格式整理版）"></a>📘 DNS 相关对话（Q&#x2F;A 格式整理版）</h1><h2 id="Q1-我记得还有一个设计上-HTTPDNS，也给我讲讲？"><a href="#Q1-我记得还有一个设计上-HTTPDNS，也给我讲讲？" class="headerlink" title="Q1. 我记得还有一个设计上 HTTPDNS，也给我讲讲？"></a>Q1. 我记得还有一个设计上 HTTPDNS，也给我讲讲？</h2><p><strong>A：</strong><br>你可以把 HTTPDNS 理解为”DNS over HTTP&#x2F;HTTPS 的自建版本”，与 DoH（DNS<br>over HTTPS）有相似点，但定位不同。</p><p>它主要解决的问题是：<br>传统 DNS 经常被运营商劫持、污染、缓存错误，特别是在移动网络环境。</p><p>因此一些大厂（阿里、腾讯、字节）自建 HTTPDNS，让客户端通过 HTTP&#x2F;HTTPS<br>访问专门的 DNS 服务，以避免运营商干扰。</p><hr><h2 id="Q2-我的理解是：HTTPDNS-是一个单独分类，请帮我对比传统-DNS-和-HTTPDNS？"><a href="#Q2-我的理解是：HTTPDNS-是一个单独分类，请帮我对比传统-DNS-和-HTTPDNS？" class="headerlink" title="Q2. 我的理解是：HTTPDNS 是一个单独分类，请帮我对比传统 DNS 和 HTTPDNS？"></a>Q2. 我的理解是：HTTPDNS 是一个单独分类，请帮我对比传统 DNS 和 HTTPDNS？</h2><p><strong>A：</strong><br>下面是传统 DNS 与 HTTPDNS 的对比表：</p><hr><p>  对比项               传统 DNS                  HTTPDNS</p><hr><p>  传输协议             UDP&#x2F;53（也可 TCP&#x2F;53）     HTTP 或 HTTPS</p><p>  易受运营商劫持       是                        否</p><p>  数据格式             DNS 二进制格式            JSON &#x2F; 自定义格式</p><p>  走代理               通常不走                  容易走（HTTP&#x2F;HTTPS）</p><p>  CDN 就近策略         不一定准确（取决于本地    可以根据真实客户端 IP<br>                       DNS）                     精确调度</p><p>  移动网络环境         易被劫持                  非常稳定</p><p>  延迟                 很低                      一般略高（HTTP 请求）</p><p>  适合场景             PC、固定网络              移动<br>                                             APP、大厂业务、特定网络环境</p><hr><hr><h2 id="Q3-但是实际上-HTTPDNS-服务器的解析也要依赖传统-DNS？"><a href="#Q3-但是实际上-HTTPDNS-服务器的解析也要依赖传统-DNS？" class="headerlink" title="Q3. 但是实际上 HTTPDNS 服务器的解析也要依赖传统 DNS？"></a>Q3. 但是实际上 HTTPDNS 服务器的解析也要依赖传统 DNS？</h2><p><strong>A：</strong><br>是的，这是关键点。</p><p>HTTPDNS 只是”客户端访问 DNS 的方式改变了”，但它本质上仍要：</p><ul><li>向权威 DNS 获取域名记录\</li><li>或自己作为递归去向 Root → TLD → Authoritative 逐级解析</li></ul><p>HTTPDNS 不会改变 DNS 的基础结构，只是绕过运营商的 Local DNS。</p><hr><h2 id="Q4-HTTPDNS-是否需要在-DNS-中填写-DNS-服务器域名？还是直接使用-IP-构造-HTTP-访问？"><a href="#Q4-HTTPDNS-是否需要在-DNS-中填写-DNS-服务器域名？还是直接使用-IP-构造-HTTP-访问？" class="headerlink" title="Q4. HTTPDNS 是否需要在 DNS 中填写 DNS 服务器域名？还是直接使用 IP 构造 HTTP 访问？"></a>Q4. HTTPDNS 是否需要在 DNS 中填写 DNS 服务器域名？还是直接使用 IP 构造 HTTP 访问？</h2><p><strong>A：</strong><br>HTTPDNS 客户端通常必须 <strong>直接使用固定 IP</strong> 访问 HTTPDNS 服务。<br>不能用域名，否则就又要解析 DNS，形成循环。</p><p>因此请求通常是：</p><pre><code>http://203.107.1.1/resolve?host=example.com</code></pre><p>或通过 HTTPS：</p><pre><code>https://203.107.1.1/resolve</code></pre><p>IP 是写死的。</p><hr><h2 id="Q5-但是一般来说，HTTP-层的-IP-直连处于安全考虑应该关闭的吧？"><a href="#Q5-但是一般来说，HTTP-层的-IP-直连处于安全考虑应该关闭的吧？" class="headerlink" title="Q5. 但是一般来说，HTTP 层的 IP 直连处于安全考虑应该关闭的吧？"></a>Q5. 但是一般来说，HTTP 层的 IP 直连处于安全考虑应该关闭的吧？</h2><p><strong>A：</strong><br>这里需要区分两类服务：</p><h3 id="1）普通-Web-服务"><a href="#1）普通-Web-服务" class="headerlink" title="1）普通 Web 服务"></a><strong>1）普通 Web 服务</strong></h3><p>大多数网站<strong>确实会关闭 IP 直连</strong>：</p><ul><li>防止绕过 CDN\</li><li>防止源站暴露\</li><li>防止攻击者扫描\</li><li>防止证书 mismatch</li></ul><h3 id="2）HTTPDNS-服务"><a href="#2）HTTPDNS-服务" class="headerlink" title="2）HTTPDNS 服务"></a><strong>2）HTTPDNS 服务</strong></h3><p>这是基础设施服务 → 必须支持 IP 直连。<br>否则客户端无法启动 DNS 解析链路。</p><p>所以：</p><ul><li>业务网站：IP 直连关闭\</li><li>HTTPDNS：必须开放 IP</li></ul><p>两者不矛盾。</p><hr><h2 id="Q6-类似于”浏览器里填的是-IP，但是在协议里还是域名”？"><a href="#Q6-类似于”浏览器里填的是-IP，但是在协议里还是域名”？" class="headerlink" title="Q6. 类似于”浏览器里填的是 IP，但是在协议里还是域名”？"></a>Q6. 类似于”浏览器里填的是 IP，但是在协议里还是域名”？</h2><p><strong>A：</strong><br>对 HTTPS 来说确实如此。</p><p>流程是：</p><ul><li>浏览器访问 IP\</li><li>但 TLS 握手会发 <strong>SNI（Server Name Indication）</strong>，里面包含域名\</li><li>服务器根据域名选择证书和站点</li></ul><p>若不发送 SNI 或证书不匹配，服务器通常拒绝访问。</p><hr><h2 id="Q7-但是实际上构造攻击时也可以使用这种方式，那关闭-IP-直接访问的意义是什么？"><a href="#Q7-但是实际上构造攻击时也可以使用这种方式，那关闭-IP-直接访问的意义是什么？" class="headerlink" title="Q7. 但是实际上构造攻击时也可以使用这种方式，那关闭 IP 直接访问的意义是什么？"></a>Q7. 但是实际上构造攻击时也可以使用这种方式，那关闭 IP 直接访问的意义是什么？</h2><p><strong>A：</strong><br><strong>关闭 IP<br>直连并不是为了”绝对阻止攻击”，而是为了”降低攻击面、增加成本”。</strong></p><p>意义包括：</p><ul><li>隐藏源站 IP\</li><li>防止绕过 CDN &#x2F; WAF\</li><li>过滤扫描器（大多数扫描器不会构造复杂 SNI&#x2F;Host）\</li><li>避免证书泄露源站信息\</li><li>阻止简单脚本攻击\</li><li>缩小暴露面</li></ul><p>这是典型的防御原则：</p><blockquote><p><strong>不是阻止攻击，而是让攻击变得困难且成本高。</strong></p></blockquote><hr><h2 id="Q8-但其实用反向-DNS-获取真实业务域名，再伪造-Host-也可以攻击？"><a href="#Q8-但其实用反向-DNS-获取真实业务域名，再伪造-Host-也可以攻击？" class="headerlink" title="Q8. 但其实用反向 DNS 获取真实业务域名，再伪造 Host 也可以攻击？"></a>Q8. 但其实用反向 DNS 获取真实业务域名，再伪造 Host 也可以攻击？</h2><p><strong>A：</strong><br>这是一个常见误区，实际情况如下：</p><h3 id="1）绝大多数业务-IP-没有-PTR-记录"><a href="#1）绝大多数业务-IP-没有-PTR-记录" class="headerlink" title="1）绝大多数业务 IP 没有 PTR 记录"></a><strong>1）绝大多数业务 IP 没有 PTR 记录</strong></h3><p>尤其是云服务、CDN、源站。</p><h3 id="2）有-PTR-的-IP-也通常不是业务域名"><a href="#2）有-PTR-的-IP-也通常不是业务域名" class="headerlink" title="2）有 PTR 的 IP 也通常不是业务域名"></a><strong>2）有 PTR 的 IP 也通常不是业务域名</strong></h3><p>多是：</p><pre><code>xxx.provider.netxxx.cloud.internal</code></pre><p>完全无意义。</p><h3 id="3）即便知道域名，也无法绕过："><a href="#3）即便知道域名，也无法绕过：" class="headerlink" title="3）即便知道域名，也无法绕过："></a><strong>3）即便知道域名，也无法绕过</strong>：</h3><ul><li>CDN\</li><li>WAF\</li><li>Token &#x2F; Session &#x2F; Cookie 鉴权\</li><li>API gateway 限制</li></ul><h3 id="4）源站通常不暴露"><a href="#4）源站通常不暴露" class="headerlink" title="4）源站通常不暴露"></a><strong>4）源站通常不暴露</strong></h3><p>因为：</p><ul><li>托管在私网\</li><li>仅 CDN IP 白名单可访问\</li><li>或通过 SLB 内部网络访问</li></ul><blockquote><p><strong>所以反向 DNS 不会让攻击更容易。</strong></p></blockquote><hr><h2 id="Q9-也就是说并非”阻止”，而是”加大难度”？"><a href="#Q9-也就是说并非”阻止”，而是”加大难度”？" class="headerlink" title="Q9. 也就是说并非”阻止”，而是”加大难度”？"></a>Q9. 也就是说并非”阻止”，而是”加大难度”？</h2><p><strong>A：</strong><br>完全正确。</p><p>这正是现代安全的核心思想：</p><blockquote><p><strong>安全不是绝对阻止，而是尽可能提高攻击难度，使其成本超出价值。</strong></p></blockquote><p>IP 直连关闭、域名 Host 验证、CDN 前置……都是这一策略的表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📘-DNS-相关对话（Q-A-格式整理版）&quot;&gt;&lt;a href=&quot;#📘-DNS-相关对话（Q-A-格式整理版）&quot; class=&quot;headerlink&quot; title=&quot;📘 DNS 相关对话（Q&amp;#x2F;A 格式整理版）&quot;&gt;&lt;/a&gt;📘 DNS 相关对话（Q&amp;#</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库的三种索引</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B4%A2%E5%BC%95/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-01T16:58:26.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库索引类型总结"><a href="#数据库索引类型总结" class="headerlink" title="数据库索引类型总结"></a>数据库索引类型总结</h1><p>数据库常见的索引类型有 <strong>Hash索引</strong>、<strong>Tree索引（B-Tree&#x2F;B+Tree）</strong> 和 <strong>BitMap索引</strong>。下面是详细对比。</p><hr><h2 id="1-Hash-索引"><a href="#1-Hash-索引" class="headerlink" title="1. Hash 索引"></a>1. Hash 索引</h2><p><strong>原理：</strong><br>通过哈希函数将键值映射到哈希表槽位，直接定位数据。</p><p><strong>特点：</strong>  </p><ul><li>查询速度快（精确匹配 O(1)）  </li><li>不支持范围查询（<code>&gt;</code>、<code>BETWEEN</code> 等）  </li><li>可能存在哈希冲突，需要链表等方法解决</li></ul><p><strong>适用场景：</strong>  </p><ul><li>高速精确匹配查询  </li><li>不需要排序或范围查找</li></ul><p><strong>缺点：</strong>  </p><ul><li>不支持范围查询  </li><li>哈希冲突可能影响性能  </li><li>内存占用较大</li></ul><hr><h2 id="2-Tree-索引（B-Tree-B-Tree）"><a href="#2-Tree-索引（B-Tree-B-Tree）" class="headerlink" title="2. Tree 索引（B-Tree&#x2F;B+Tree）"></a>2. Tree 索引（B-Tree&#x2F;B+Tree）</h2><p><strong>原理：</strong><br>采用平衡树（B-Tree&#x2F;B+Tree），节点按键值有序，叶子节点存储数据指针。  </p><p><strong>特点：</strong>  </p><ul><li>支持范围查询（<code>&lt;, &gt;, BETWEEN</code>）  </li><li>支持精确查询  </li><li>查找复杂度 O(log n)</li></ul><p><strong>适用场景：</strong>  </p><ul><li>需要排序、范围查询或模糊查询  </li><li>高并发场景</li></ul><p><strong>缺点：</strong>  </p><ul><li>插入&#x2F;删除可能涉及节点分裂&#x2F;合并，开销较大  </li><li>占用空间比Hash略多</li></ul><hr><h2 id="3-BitMap-索引（位图索引）"><a href="#3-BitMap-索引（位图索引）" class="headerlink" title="3. BitMap 索引（位图索引）"></a>3. BitMap 索引（位图索引）</h2><p><strong>原理：</strong><br>用位向量表示每个值在表中对应行的存在与否，通过位运算快速查询。</p><p><strong>特点：</strong>  </p><ul><li>查询效率高（尤其低基数字段）  </li><li>占用空间小（可压缩）  </li><li>支持复杂条件组合的快速查询</li></ul><p><strong>适用场景：</strong>  </p><ul><li>只读或少量更新的场景  </li><li>字段基数低（如性别、状态）  </li><li><a href="./OLAP%E6%95%B0%E6%8D%AE%E5%BA%93.md">OLAP分析型数据库</a></li></ul><p><strong>缺点：</strong>  </p><ul><li>高基数字段不适合  </li><li>更新成本高</li></ul><hr><h2 id="索引对比总结"><a href="#索引对比总结" class="headerlink" title="索引对比总结"></a>索引对比总结</h2><table><thead><tr><th>特性</th><th>Hash索引</th><th>Tree索引 (B+Tree)</th><th>BitMap索引</th></tr></thead><tbody><tr><td>精确查询</td><td>✅ 很快</td><td>✅ 快</td><td>✅ 快</td></tr><tr><td>范围查询</td><td>❌</td><td>✅</td><td>✅（低基数）</td></tr><tr><td>排序</td><td>❌</td><td>✅</td><td>✅（低基数）</td></tr><tr><td>占用空间</td><td>中等&#x2F;大</td><td>中等</td><td>低（基数低）</td></tr><tr><td>更新&#x2F;插入</td><td>快</td><td>中等</td><td>慢</td></tr><tr><td>最适场景</td><td>精确查找</td><td>范围查询、排序</td><td>OLAP分析、低基数字段</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库索引类型总结&quot;&gt;&lt;a href=&quot;#数据库索引类型总结&quot; class=&quot;headerlink&quot; title=&quot;数据库索引类型总结&quot;&gt;&lt;/a&gt;数据库索引类型总结&lt;/h1&gt;&lt;p&gt;数据库常见的索引类型有 &lt;strong&gt;Hash索引&lt;/strong&gt;、&lt;stron</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>cgroup</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/cgroup/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/cgroup/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-01T17:21:25.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-cgroup-笔记总结"><a href="#Linux-cgroup-笔记总结" class="headerlink" title="Linux cgroup 笔记总结"></a>Linux cgroup 笔记总结</h1><h2 id="1-名词定义"><a href="#1-名词定义" class="headerlink" title="1. 名词定义"></a>1. 名词定义</h2><ul><li><p><strong>cgroup（Control Group）</strong><br>Linux 内核提供的资源管理机制，用于对一组进程进行资源限制、监控和控制。</p></li><li><p><strong>controller（子系统 &#x2F; 控制器）</strong><br>每种资源类型的控制模块，例如：</p><ul><li><code>cpu</code>：CPU 时间分配  </li><li><code>memory</code>：内存使用限制  </li><li><code>blkio</code>：磁盘 I&#x2F;O 限制</li></ul></li><li><p><strong>hierarchy（层级 &#x2F; 树）</strong><br>cgroup 组织成树状结构，每个节点是一个 cgroup，挂载在文件系统下（如 <code>/sys/fs/cgroup</code>）。</p></li><li><p><strong>同一个 cgroup</strong><br>指 <strong>共享同一套资源限制的一组进程</strong>。内核会统一统计这些进程的资源使用，并施加相同的限制。</p></li><li><p><strong>CPU 相对优先级（cpu.shares）</strong><br>表示 cgroup 在 CPU 竞争时的权重比例，默认 1024。  </p><ul><li>只影响 CPU 分配比例，不限制最大使用量。</li></ul></li><li><p><strong>CPU 绝对限制（cpu.cfs_quota_us &#x2F; cpu.cfs_period_us）</strong><br>表示每个调度周期内该 cgroup <strong>最多能使用的 CPU 时间</strong>。  </p><ul><li>超过 quota 的线程不会被调度，硬性限制。</li></ul></li></ul><hr><h2 id="2-cgroup-原理"><a href="#2-cgroup-原理" class="headerlink" title="2. cgroup 原理"></a>2. cgroup 原理</h2><ol><li><p><strong>层级 + controller</strong>  </p><ul><li>cgroup 通过层级树组织，每个节点可挂载一个或多个 controller。</li><li>controller 提供对特定资源的管理。</li></ul></li><li><p><strong>进程与 cgroup</strong>  </p><ul><li>cgroup 管理的是 <strong>task_struct（进程&#x2F;线程）</strong>。</li><li>进程加入 cgroup 后，受到该 cgroup 所有 controller 的限制。</li></ul></li><li><p><strong>资源限制类型</strong>  </p><ul><li><strong>绝对限制（Quota &#x2F; Limit）</strong>：硬性上限，如 <code>cpu.cfs_quota_us</code> 或 <code>memory.limit_in_bytes</code>  </li><li><strong>相对优先级（Shares &#x2F; 权重）</strong>：在资源竞争时按比例分配，如 <code>cpu.shares</code>、<code>blkio.weight</code></li></ul></li><li><p><strong>调度逻辑</strong>（以 CPU 为例）  </p><ul><li>先满足 <strong>绝对限制</strong>（quota）  </li><li>剩余资源按 <strong>相对优先级</strong> 分配  </li><li>同一 cgroup 内所有线程共享 quota 和 shares 配置</li></ul></li><li><p><strong>父子 cgroup 限制与覆盖</strong>  </p><ul><li>子 cgroup 可以 <strong>覆盖父节点的限制</strong>，例如 CPU shares 可以改成不同值  </li><li>内核不会自动“取最小值”或“取最大值”，子节点生效的是自己设置的限制  </li><li>某些资源（如 memory）可能仍受父节点总量约束，但调度器不会对 quota 做 min&#x2F;max 处理  </li><li><strong>子 cgroup quota 大于父节点 quota</strong>  <ul><li>子 cgroup 可以设置比父节点更大的 quota  </li><li><strong>实际可用 CPU 仍受父节点总 quota 限制</strong>  </li><li>内核调度逻辑：子 cgroup 想用的 CPU &#x3D; min(父节点剩余 CPU, 子节点 quota)</li></ul></li></ul></li></ol><hr><h2 id="3-常见问题及解释"><a href="#3-常见问题及解释" class="headerlink" title="3. 常见问题及解释"></a>3. 常见问题及解释</h2><h3 id="Q1-一个-cgroup-能同时设置绝对限制和相对权重吗？"><a href="#Q1-一个-cgroup-能同时设置绝对限制和相对权重吗？" class="headerlink" title="Q1: 一个 cgroup 能同时设置绝对限制和相对权重吗？"></a>Q1: 一个 cgroup 能同时设置绝对限制和相对权重吗？</h3><p><strong>A:</strong> 可以。  </p><ul><li>quota &#x3D; CPU 的硬性上限  </li><li>shares &#x3D; 剩余 CPU 的分配比例  </li><li>调度器会先限制 quota，再按 shares 分配剩余 CPU</li></ul><h3 id="Q2-如果同一系统中，一个-cgroup-用绝对限制，一个用相对权重，会怎样？"><a href="#Q2-如果同一系统中，一个-cgroup-用绝对限制，一个用相对权重，会怎样？" class="headerlink" title="Q2: 如果同一系统中，一个 cgroup 用绝对限制，一个用相对权重，会怎样？"></a>Q2: 如果同一系统中，一个 cgroup 用绝对限制，一个用相对权重，会怎样？</h3><p><strong>A:</strong>  </p><ul><li>绝对限制 cgroup：最多使用 quota 指定的 CPU 时间  </li><li>相对权重 cgroup：分配剩余 CPU 按权重比例  </li><li>绝对限制不会因为有相对 cgroup 而减少</li></ul><h3 id="Q3-quota-很高，shares-很低会怎样？"><a href="#Q3-quota-很高，shares-很低会怎样？" class="headerlink" title="Q3: quota 很高，shares 很低会怎样？"></a>Q3: quota 很高，shares 很低会怎样？</h3><p><strong>A:</strong>  </p><ul><li>quota 很高 &#x3D; 硬上限很大  </li><li>shares 很低 &#x3D; 在 CPU 竞争时优先级低  </li><li>实际 CPU 占用可能远低于 quota，因为 shares 决定了分配顺序</li></ul><h3 id="Q4-同一个-cgroup-内，能让部分线程使用绝对限制，部分线程使用相对优先级吗？"><a href="#Q4-同一个-cgroup-内，能让部分线程使用绝对限制，部分线程使用相对优先级吗？" class="headerlink" title="Q4: 同一个 cgroup 内，能让部分线程使用绝对限制，部分线程使用相对优先级吗？"></a>Q4: 同一个 cgroup 内，能让部分线程使用绝对限制，部分线程使用相对优先级吗？</h3><p><strong>A:</strong> 不可以。  </p><ul><li>CPU controller 的限制是 <strong>cgroup 级别的</strong>  </li><li>要实现不同策略，需要将线程划分到不同 cgroup</li></ul><hr><h2 id="4-常用文件接口（以-CPU-为例）"><a href="#4-常用文件接口（以-CPU-为例）" class="headerlink" title="4. 常用文件接口（以 CPU 为例）"></a>4. 常用文件接口（以 CPU 为例）</h2><ul><li><code>cpu.shares</code>：相对权重  </li><li><code>cpu.cfs_quota_us</code>：绝对 CPU 限制（微秒）  </li><li><code>cpu.cfs_period_us</code>：调度周期（微秒）  </li><li><code>tasks</code>：写入 PID，将进程加入 cgroup</li></ul><hr><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><ol><li>cgroup &#x3D; <strong>共享同一套资源限制的进程组</strong>  </li><li>controller &#x3D; <strong>管理特定资源的模块</strong>  </li><li>CPU 调度可同时配置：<ul><li><strong>quota（绝对限制）</strong>：硬性上限  </li><li><strong>shares（相对优先级）</strong>：剩余 CPU 分配比例</li></ul></li><li>调度逻辑：<ol><li>先满足 quota  </li><li>剩余资源按 shares 分配</li></ol></li><li>父子 cgroup 限制：<ul><li>子 cgroup 可以覆盖父节点的限制  </li><li>内核不会自动取最小或最大值  </li><li>父节点 quota 会约束子节点实际可用 CPU  </li><li>子 cgroup quota 大于父节点也无法突破父节点总量</li></ul></li><li>不同策略的线程必须放入 <strong>不同 cgroup</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-cgroup-笔记总结&quot;&gt;&lt;a href=&quot;#Linux-cgroup-笔记总结&quot; class=&quot;headerlink&quot; title=&quot;Linux cgroup 笔记总结&quot;&gt;&lt;/a&gt;Linux cgroup 笔记总结&lt;/h1&gt;&lt;h2 id=&quot;1-名词定</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="系统工具" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp挥手与断开</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-05T09:37:46.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Simultaneous-FIN（TCP-同时关闭）系统整理"><a href="#Simultaneous-FIN（TCP-同时关闭）系统整理" class="headerlink" title="Simultaneous FIN（TCP 同时关闭）系统整理"></a>Simultaneous FIN（TCP 同时关闭）系统整理</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p><strong>Simultaneous FIN</strong> 又叫 <strong>TCP Simultaneous Close</strong>，指的是：</p><ul><li>TCP 连接的双方几乎同时发起关闭连接请求</li><li>双方都发送了 <code>FIN</code> 报文，而不是传统的主动关闭与被动关闭模式</li><li>最终仍然能够可靠地关闭 TCP 连接</li></ul><blockquote><p>简单理解：双方几乎同时挂电话，最终电话顺利断开。</p></blockquote><hr><h2 id="2-与普通-TCP-四次挥手的区别"><a href="#2-与普通-TCP-四次挥手的区别" class="headerlink" title="2. 与普通 TCP 四次挥手的区别"></a>2. 与普通 TCP 四次挥手的区别</h2><table><thead><tr><th>特性</th><th>普通 TCP 四次挥手</th><th>Simultaneous FIN</th></tr></thead><tbody><tr><td>发起者</td><td>一方主动关闭，一方被动关闭</td><td>双方几乎同时主动关闭</td></tr><tr><td>FIN 报文</td><td>单方发送</td><td>双方几乎同时发送</td></tr><tr><td>ACK 回复</td><td>被动方回复 ACK</td><td>双方互相回复 ACK</td></tr><tr><td>状态顺序</td><td><code>ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED</code></td><td>双方同时经历 <code>FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED</code></td></tr><tr><td>场景</td><td>客户端主动关闭，服务器被动关闭</td><td>对等通信（P2P）关闭连接</td></tr></tbody></table><hr><h2 id="3-关闭流程（详细三步）"><a href="#3-关闭流程（详细三步）" class="headerlink" title="3. 关闭流程（详细三步）"></a>3. 关闭流程（详细三步）</h2><h3 id="3-1-初始状态"><a href="#3-1-初始状态" class="headerlink" title="3.1 初始状态"></a>3.1 初始状态</h3><p>假设两台主机 A 和 B 已建立连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: ESTABLISHED</span><br><span class="line">B: ESTABLISHED</span><br></pre></td></tr></table></figure><ul><li>A → B：发送 FIN</li><li>B → A：发送 FIN</li><li>两台主机状态变为 <code>FIN_WAIT_1</code></li></ul><hr><h3 id="3-2-收到对方-FIN"><a href="#3-2-收到对方-FIN" class="headerlink" title="3.2 收到对方 FIN"></a>3.2 收到对方 FIN</h3><ul><li>A 收到 B 的 FIN → 回复 ACK（确认号 &#x3D; B 的序列号 +1）</li><li>B 收到 A 的 FIN → 回复 ACK（确认号 &#x3D; A 的序列号 +1）</li><li>双方状态变为 <code>FIN_WAIT_2</code></li></ul><blockquote><p>注意：如果 FIN 与 ACK 交叉到达，TCP 可以在同一报文中同时发送 <code>FIN+ACK</code>。</p></blockquote><hr><h3 id="3-3-TIME-WAIT-与关闭"><a href="#3-3-TIME-WAIT-与关闭" class="headerlink" title="3.3 TIME_WAIT 与关闭"></a>3.3 TIME_WAIT 与关闭</h3><ul><li>双方进入 <code>TIME_WAIT</code> 状态，以确保延迟报文不会影响新连接</li><li>TIME_WAIT 超时后，状态变为 <code>CLOSED</code></li></ul><hr><h2 id="4-流程时序图"><a href="#4-流程时序图" class="headerlink" title="4. 流程时序图"></a>4. 流程时序图</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">时间 --&gt;</span><br><span class="line">  A                               B</span><br><span class="line">  | FIN ------------------------&gt; |</span><br><span class="line">  | &lt;------------------------ FIN |</span><br><span class="line">  | ACK ------------------------&gt; |</span><br><span class="line">  | &lt;------------------------ ACK |</span><br><span class="line">  FIN_WAIT_2                     FIN_WAIT_2</span><br><span class="line">  |                             |</span><br><span class="line">  TIME_WAIT                     TIME_WAIT</span><br><span class="line">  |                             |</span><br><span class="line">  CLOSED                        CLOSED</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ul><li>双向箭头表示 TCP 报文流向</li><li>双方最终进入 <code>CLOSED</code>，连接完全关闭</li><li>若 FIN 与 ACK 交叉，可合并为 <code>FIN+ACK</code> 报文</li></ul></blockquote><hr><h2 id="5-特点与要点"><a href="#5-特点与要点" class="headerlink" title="5. 特点与要点"></a>5. 特点与要点</h2><ul><li><p><strong>双向主动关闭</strong><br>双方都主动发起 FIN，TCP 自动处理报文确认</p></li><li><p><strong>可靠性</strong><br>TCP 的序列号、确认号、重传机制仍然生效，保证连接正常关闭</p></li><li><p><strong>全双工释放</strong><br>双方都可以在发送 FIN 之前继续发送剩余数据</p></li><li><p><strong>少见场景</strong><br>对等通信（P2P）中可能出现，普通客户端-服务器模式下较少</p></li><li><p><strong>状态机</strong><br>双方都经历 <code>FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED</code></p></li></ul><hr><h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h2><ul><li><p><strong>端口释放</strong><br>TIME_WAIT 状态保证延迟报文不会影响新连接，防止端口冲突</p></li><li><p><strong>防火墙与 NAT</strong><br>防火墙或 NAT 可能会阻止 FIN 报文，需要确保双方网络环境允许</p></li><li><p><strong>TCP 标准支持</strong><br>RFC 793 支持 Simultaneous Close，但在实际网络中较少使用</p></li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li>Simultaneous FIN 是 TCP 的 <strong>特殊关闭机制</strong></li><li>双方几乎同时发送 FIN，最终仍能可靠关闭连接</li><li>本质上仍遵循 TCP 四次挥手，只是双方都主动关闭</li><li>典型应用：对等网络通信（P2P）关闭连接</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Simultaneous-FIN（TCP-同时关闭）系统整理&quot;&gt;&lt;a href=&quot;#Simultaneous-FIN（TCP-同时关闭）系统整理&quot; class=&quot;headerlink&quot; title=&quot;Simultaneous FIN（TCP 同时关闭）系统整理&quot;&gt;</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="传输层协议" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="TCP" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp握手与链接</title>
    <link href="http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2025/12/02/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</id>
    <published>2025-12-01T16:41:00.000Z</published>
    <updated>2025-12-05T08:57:22.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻常三次握手"><a href="#寻常三次握手" class="headerlink" title="寻常三次握手"></a>寻常三次握手</h1><p>略，大部分的书上都会说</p><h1 id="Simultaneous-SYN（TCP-同时打开）系统整理"><a href="#Simultaneous-SYN（TCP-同时打开）系统整理" class="headerlink" title="Simultaneous SYN（TCP 同时打开）系统整理"></a>Simultaneous SYN（TCP 同时打开）系统整理</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p><strong>Simultaneous SYN</strong> 又叫 <strong>TCP Simultaneous Open</strong>，指的是：</p><ul><li>TCP 连接的双方几乎同时发起建立连接请求</li><li>双方都发送了 <code>SYN</code> 报文，而不是传统的客户端-服务器模式</li><li>最终仍然能够成功建立一个可靠的双向 TCP 连接</li></ul><blockquote><p>简单理解：双方都想主动打电话，结果电话“撞”在一起，最终双方都能通话。</p></blockquote><hr><h2 id="2-与普通-TCP-建立连接的区别"><a href="#2-与普通-TCP-建立连接的区别" class="headerlink" title="2. 与普通 TCP 建立连接的区别"></a>2. 与普通 TCP 建立连接的区别</h2><table><thead><tr><th>特性</th><th>普通 TCP 三次握手</th><th>Simultaneous SYN</th></tr></thead><tbody><tr><td>发起者</td><td>明确客户端 → 服务器</td><td>双方都主动发起</td></tr><tr><td>SYN 报文</td><td>单方发送</td><td>双方几乎同时发送</td></tr><tr><td>ACK 回复</td><td>服务器回复客户端的 SYN</td><td>双方互相回复对方的 SYN</td></tr><tr><td>状态顺序</td><td><code>CLOSED → SYN_SENT → SYN_RECEIVED → ESTABLISHED</code></td><td>双方都经历 <code>CLOSED → SYN_SENT → SYN_RECEIVED → ESTABLISHED</code></td></tr><tr><td>场景</td><td>常规客户端-服务器通信</td><td>对等通信（P2P）</td></tr></tbody></table><hr><h2 id="3-建立流程（详细三步）"><a href="#3-建立流程（详细三步）" class="headerlink" title="3. 建立流程（详细三步）"></a>3. 建立流程（详细三步）</h2><h3 id="3-1-初始状态"><a href="#3-1-初始状态" class="headerlink" title="3.1 初始状态"></a>3.1 初始状态</h3><p>假设两台主机 A 和 B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: CLOSED</span><br><span class="line">B: CLOSED</span><br></pre></td></tr></table></figure><ul><li>A → B：发送 SYN（序列号 x）</li><li>B → A：发送 SYN（序列号 y）</li><li>两台主机状态变为 <code>SYN_SENT</code></li></ul><hr><h3 id="3-2-收到对方-SYN"><a href="#3-2-收到对方-SYN" class="headerlink" title="3.2 收到对方 SYN"></a>3.2 收到对方 SYN</h3><ul><li>A 收到 B 的 SYN → 回复 <code>SYN+ACK</code>（确认号 y+1，序列号 x）</li><li>B 收到 A 的 SYN → 回复 <code>SYN+ACK</code>（确认号 x+1，序列号 y）</li><li>状态变为 <code>SYN_RECEIVED</code></li></ul><hr><h3 id="3-3-最终确认"><a href="#3-3-最终确认" class="headerlink" title="3.3 最终确认"></a>3.3 最终确认</h3><ul><li>A 收到 B 的 <code>SYN+ACK</code> → 发送 <code>ACK</code>（确认号 y+1）</li><li>B 收到 A 的 <code>SYN+ACK</code> → 发送 <code>ACK</code>（确认号 x+1）</li><li>双方状态最终都变为 <code>ESTABLISHED</code></li></ul><hr><h2 id="4-流程时序图"><a href="#4-流程时序图" class="headerlink" title="4. 流程时序图"></a>4. 流程时序图</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">时间 --&gt;</span><br><span class="line">  A                               B</span><br><span class="line">  | SYN(x) ---------------------&gt; |</span><br><span class="line">  | &lt;-------------------- SYN(y)  |</span><br><span class="line">  | SYN+ACK(x,y+1) -------------&gt; |</span><br><span class="line">  | &lt;------------ SYN+ACK(y,x+1)  |</span><br><span class="line">  | ACK(y+1) ------------------&gt;  |</span><br><span class="line">  | &lt;------------------ ACK(x+1)  |</span><br><span class="line">  ESTABLISHED                     ESTABLISHED</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ul><li>横向箭头表示 TCP 报文流向</li><li><code>x</code> 和 <code>y</code> 分别为双方的初始序列号</li><li>双方最终都进入 <code>ESTABLISHED</code> 状态</li></ul></blockquote><hr><h2 id="5-特点与要点"><a href="#5-特点与要点" class="headerlink" title="5. 特点与要点"></a>5. 特点与要点</h2><ul><li><p><strong>全双工通道</strong><br>最终建立的 TCP 连接和普通 TCP 连接一样，全双工可靠通信</p></li><li><p><strong>双方都是主动发起者</strong><br>没有传统客户端&#x2F;服务器角色<br>对等网络（P2P）中可能出现</p></li><li><p><strong>可靠性</strong><br>TCP 序列号、确认号、重传机制依然生效</p></li><li><p><strong>少见场景</strong><br>普通客户端-服务器模式下几乎不会用到<br>对等通信、某些分布式系统或 P2P 协议可能会遇到</p></li><li><p><strong>状态机</strong><br>双方都经历 <code>SYN_SENT → SYN_RECEIVED → ESTABLISHED</code><br>与普通三次握手类似，但双方都发送了 SYN</p></li></ul><hr><h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h2><ul><li><p><strong>端口监听问题</strong><br>Simultaneous SYN 仍然需要一方或双方的端口处于监听状态，否则会被拒绝</p></li><li><p><strong>防火墙和 NAT</strong><br>某些防火墙可能阻止同时发起的 SYN 报文<br>NAT 环境下可能会导致连接失败</p></li><li><p><strong>TCP 标准支持</strong><br>RFC 793 明确支持 Simultaneous Open<br>实际上，很多操作系统都实现了，但不常用</p></li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul><li>Simultaneous SYN 是 TCP 的一个 <strong>特殊建立连接机制</strong></li><li>双方都主动发送 SYN，最终仍然建立可靠连接</li><li>本质上仍是 TCP 的三次握手，只是双方都是主动发起者</li><li>典型应用：对等网络通信（P2P）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寻常三次握手&quot;&gt;&lt;a href=&quot;#寻常三次握手&quot; class=&quot;headerlink&quot; title=&quot;寻常三次握手&quot;&gt;&lt;/a&gt;寻常三次握手&lt;/h1&gt;&lt;p&gt;略，大部分的书上都会说&lt;/p&gt;
&lt;h1 id=&quot;Simultaneous-SYN（TCP-同时打开）系统整理</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="传输层协议" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="TCP" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/TCP/"/>
    
    
  </entry>
  
  <entry>
    <title>锁相关知识点</title>
    <link href="http://example.com/2025/12/01/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/JAVA/%E9%94%81%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2025/12/01/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/JAVA/%E9%94%81%E9%83%A8%E5%88%86/</id>
    <published>2025-12-01T02:15:00.000Z</published>
    <updated>2025-12-01T16:41:48.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java的锁其实主要可以分成三种，syncro锁，reentrain锁，以及更经典传统的无锁机制。</p><h1 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h1><p>synchronized 是 Java 的内置锁（Intrinsic Lock &#x2F; Monitor Lock），作用：</p><p>同一时刻只能有一个线程进入被同步的代码块或方法（互斥）</p><p>保证线程之间的 可见性（基于进入与退出 Monitor 的内存语义）</p><p>自动加锁、自动释放（异常也会释放）</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lockObject) &#123;</span><br><span class="line">    // 临界区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void test() &#123;</span><br><span class="line">    // 临界区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized void testStatic() &#123;</span><br><span class="line">    // 临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，后面两种修饰方法在锁上，等效于将本实例或者本class作为锁对象的第一种方法，因此这里会产生一个问题，如果两个不同的代码段使用第二种方法进行竞争，这两个代码段也会产生一个锁竞争，这样的坏处是，可能会造成意外的锁竞争，好处是对于 ** ‘synchronizedMap’ **这样的数据结构，能保证它的多功能多线程安全。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个锁的原理是基于Monitor锁进行，每个 Java 对象都可以作为一个 Monitor，JVM 为每个对象维护一个称为 Object Monitor 的监视器结构，线程通过进入和退出 Monitor 来实现同步互斥。<br>一个 Monitor 包含：</p><p>1）Owner（持有者）</p><p>当前占用锁的线程（如果为 null，说明锁空闲）。</p><p>2）EntryList（锁竞争队列）</p><p>等待获取锁的线程队列。</p><p>3）WaitSet（等待队列）</p><p>调用 wait() 后进入此队列，等待 notify() 或 notifyAll() 唤醒。</p><p>4）recursions（重入次数）</p><p>支持可重入锁（持有者可以多次进入，同样次数退出后才能释放）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">monitorenter</span><br><span class="line">    ↓</span><br><span class="line">进入 Monitor（尝试成为 Owner）</span><br><span class="line">    ↓</span><br><span class="line">成功 → 执行临界区代码</span><br><span class="line">    ↓</span><br><span class="line">monitorexit（释放锁）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在字节码中，sync会被编译成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monitorenter</span><br><span class="line">    ... 临界区 ...</span><br><span class="line">monitorexit</span><br></pre></td></tr></table></figure><p>的形式。</p><p>同时，</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>底层使用：</p><p>AQS（AbstractQueuedSynchronizer）</p><p>CAS（compare and swap） 获取或释放锁</p><p>volatile 保证可见性</p><p>CLH 双向队列管理等待线程</p><p>LockSupport.park&#x2F;unpark 挂起与唤醒线程</p><h1 id="锁之间的比较"><a href="#锁之间的比较" class="headerlink" title="锁之间的比较"></a>锁之间的比较</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│                 Java 代码层               │</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">                 │                   │</span><br><span class="line">                 ▼                   ▼</span><br><span class="line">        synchronized 代码        ReentrantLock.lock()</span><br><span class="line">                 │                   │</span><br><span class="line">                 ▼                   ▼</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│          JVM 层（HotSpot 实现）          │</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">      Monitorenter/Monitorexit        AQS(CLH队列)+CAS</span><br><span class="line">      Monitor(WaitSet/EntryList)      LockSupport.park/unpark</span><br><span class="line">                 │                   │</span><br><span class="line">                 ▼                   ▼</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│             Native (Unsafe)               │</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">        OS Mutex / Thread Park         unsafe.park()</span><br><span class="line">        ThreadBlock/Schedule           unsafe.unpark()</span><br><span class="line">                 │                   │</span><br><span class="line">                 ▼                   ▼</span><br><span class="line">┌───────────────────────────────────────────┐</span><br><span class="line">│            OS 层 (Linux / Windows)        │</span><br><span class="line">└───────────────────────────────────────────┘</span><br><span class="line">       futex(mutex lock/wait/wake)     futex(FUTEX_WAIT/FUTEX_WAKE)</span><br><span class="line">       system call thread switch       system call thread switch</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;java的锁其实主要可以分成三种，syncro锁，reentrain锁，以及更经典传统的无锁机制。&lt;/p&gt;
&lt;h1 id=&quot;synchron</summary>
      
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="JAVA" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2025/12/01/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82/"/>
    <id>http://example.com/2025/12/01/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82/</id>
    <published>2025-11-30T16:34:35.919Z</published>
    <updated>2025-11-30T16:34:35.919Z</updated>
    
    
    
    
    <category term="八股文整理" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%85%AB%E8%82%A1%E6%96%87%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>lc 1590. 使数组和能被 P 整除</title>
    <link href="http://example.com/2025/11/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/lc%201590.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB%20P%20%E6%95%B4%E9%99%A4/"/>
    <id>http://example.com/2025/11/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/lc%201590.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB%20P%20%E6%95%B4%E9%99%A4/</id>
    <published>2025-11-30T15:59:59.000Z</published>
    <updated>2025-11-30T16:32:35.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.cn/problems/make-sum-divisible-by-p/description/">lc超链接</a></p><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>主要思想是：假设整个数组模 p 之后的结果是 x，那么我们需要在数组中移除一个子数组，使得这个子数组模 p 的结果也是 x。从数学角度可以证明，移除这个子数组后，原数组的模会减少 x，从而变成 0。</p><p>举个例子，假设有五个数，它们模 p 的结果是 x，只要移除其中一个模 p 结果为 x 的子数组，那么剩下的数模 p 就是 0。</p><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最直观的想法是：对于每一个起点 i，枚举以它为起点的所有子数组，直到找到一个子数组的模 p 结果为 x，或者遍历到数组末尾。</p><p>如果找到匹配的子数组，就用它来更新”最短子数组长度”这个变量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123;</span><br><span class="line">        //长短指针循环法</span><br><span class="line">        int n=nums.size();</span><br><span class="line">        int sum_mod=0;</span><br><span class="line">        for(auto a:nums)&#123;</span><br><span class="line">            sum_mod+=a;</span><br><span class="line">            sum_mod%=p;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum_mod==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int min_leng=INT_MAX;</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            int sum_mod_temp=0;</span><br><span class="line">            for(int j=i;j&lt;n;j++)&#123;</span><br><span class="line">                sum_mod_temp+=(nums[j]%p);</span><br><span class="line">                sum_mod_temp%=p;</span><br><span class="line">                if(sum_mod==sum_mod_temp)&#123;</span><br><span class="line">                    min_leng=min(min_leng,j-i+1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min_leng==INT_MAX || min_leng==n)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return min_leng;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>该方法会超时，最坏时间复杂度为 O(n²)。空间复杂度为 O(1)。</p><h2 id="优化算法（官解）"><a href="#优化算法（官解）" class="headerlink" title="优化算法（官解）"></a>优化算法（官解）</h2><p>另一种思路是使用前缀和配合哈希表的方法。</p><p>对于任意一个位置 i，考虑以该位置为结尾的前缀和。我们需要找到一个子数组，使得该子数组的模 p 结果等于 x。利用前缀和的性质，如果当前前缀和的模为 y，那么我们需要找到一个之前的前缀和，使得两个前缀和的模差为 x。</p><p>为了找到最短的子数组，对于任意一个位置，我们只需要找到它左边最近的一个满足条件的前缀和即可。因此，我们可以使用一个哈希表（字典），来记录每个前缀和模 p 值对应的最近位置。</p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; right_mod;</span><br><span class="line">        int sum_mod=0;</span><br><span class="line">        int n=nums.size();</span><br><span class="line">        int min_len=INT_MAX;</span><br><span class="line">        //取需要消掉的模</span><br><span class="line">        int total_x=0;</span><br><span class="line">        for(auto a:nums)&#123;</span><br><span class="line">            total_x+=a;</span><br><span class="line">            total_x%=p;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;total_x&lt;&lt;endl;</span><br><span class="line">        //在整个数组中消去一段，这一段的模差应该是total_x</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            sum_mod=(sum_mod+nums[i])%p;</span><br><span class="line"></span><br><span class="line">            if(sum_mod==total_x)&#123;</span><br><span class="line">                min_len=min(min_len,i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            if(right_mod[(sum_mod+p-total_x)%p]!=0)&#123;</span><br><span class="line">                min_len=min(min_len,i-right_mod[(sum_mod+p-total_x)%p]+1);</span><br><span class="line">                cout&lt;&lt;i-right_mod[(sum_mod+p-total_x)%p]+1&lt;&lt;&quot;-&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            right_mod[sum_mod]=i+1;</span><br><span class="line">            cout&lt;&lt;min_len&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum_mod==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return min_len==n?-1:min_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="官解"><a href="#官解" class="headerlink" title="官解"></a>官解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubarray(vector&lt;int&gt;&amp; nums, int p) &#123;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (auto num : nums) &#123;</span><br><span class="line">            x = (x + num) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, int&gt; index;</span><br><span class="line">        int y = 0, res = nums.size();</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            index[y] = i; // f[i] mod p = y，因此哈希表记录 y 对应的下标为 i</span><br><span class="line">            y = (y + nums[i]) % p;</span><br><span class="line">            if (index.count((y - x + p) % p) &gt; 0) &#123;</span><br><span class="line">                res = min(res, i - index[(y - x + p) % p] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == nums.size() ? -1 : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https://leetcode.cn/problems/make-sum-divisible-by-p/solutions/2157277/shi-shu-zu-he-neng-bei-p-zheng-chu-by-le-dob9/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>对每个数遍历一遍，时间复杂度为 O(n)。需要一个哈希表存储每个余数对应的位置，空间复杂度为 O(n)。</p><h3 id="我的解与官方解法的对比及注意事项"><a href="#我的解与官方解法的对比及注意事项" class="headerlink" title="我的解与官方解法的对比及注意事项"></a>我的解与官方解法的对比及注意事项</h3><ol><li><p><strong><code>index.count()</code> 的使用</strong>：我之前没有使用过这个方法，所以用了一个”0”值来标记某个键是否真的出现过，位置记录也需要相应的偏移，这是不必要的。使用 <code>index.count()</code> 可以直接判断键是否存在。</p></li><li><p><strong><code>sum_mod==total_x</code> 的判断</strong>：这个判断其实是没必要的，因为这个情况实际上会映射到哈希表的”0”键，可以通过哈希表统一处理。</p></li><li><p><strong>更新顺序的差异</strong>：官解中的 <code>index[y]</code> 和我的更新顺序不太一样，官解是在下一轮循环中更新的，这个顺序问题不大，但需要注意边界情况的处理。</p></li></ol><h1 id="一些笔记"><a href="#一些笔记" class="headerlink" title="一些笔记"></a>一些笔记</h1><p>涉及取模运算的问题，很多时候可以利用同余性质和哈希表来优化。</p><p>当需要优化时间复杂度时，前缀和配合哈希表往往是一个可行的思路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/make-sum-divisible-by-p/</summary>
      
    
    
    
    <category term="算法题整理" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>第一篇日志</title>
    <link href="http://example.com/2025/11/28/%E6%B5%8B%E8%AF%95%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E5%BF%97/"/>
    <id>http://example.com/2025/11/28/%E6%B5%8B%E8%AF%95%E7%94%A8/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E5%BF%97/</id>
    <published>2025-11-28T12:43:57.000Z</published>
    <updated>2025-11-29T07:42:54.808Z</updated>
    
    
    
    
    <category term="测试用" scheme="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2025/11/28/%E6%B5%8B%E8%AF%95%E7%94%A8/hello-world/"/>
    <id>http://example.com/2025/11/28/%E6%B5%8B%E8%AF%95%E7%94%A8/hello-world/</id>
    <published>2025-11-28T11:46:34.811Z</published>
    <updated>2025-11-28T11:46:34.811Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="测试用" scheme="http://example.com/categories/%E6%B5%8B%E8%AF%95%E7%94%A8/"/>
    
    
  </entry>
  
</feed>
